name: Custom macOS Client Generator
run-name: Custom macOS Client Generator

on: 
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g. 1.3.1)'
        required: true
        default: '1.3.1'
        type: string
      zip_url:
        description: 'URL to zip of json'
        required: true
        default: ''
        type: string

env:
  SCITER_RUST_VERSION: "1.75"
  RUST_VERSION: "1.75"
  MAC_RUST_VERSION: "1.81"
  FLUTTER_VERSION: "3.24.5"
  VCPKG_COMMIT_ID: "120deac3062162151622ca4860575a33844ba10b"
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
  VERSION: "${{ inputs.version }}"
  MACOS_P12_BASE64: "${{ secrets.MACOS_P12_BASE64 }}"
  UPLOAD_ARTIFACT: 'true'

jobs:
  generate-bridge:
    uses: ./.github/workflows/bridge.yml
    with:
      version: ${{ inputs.version }}

  build-for-macos:
    name: Build macOS (${{ matrix.job.arch }})
    needs: [generate-bridge]
    runs-on: ${{ matrix.job.os }}
    strategy:
      fail-fast: false
      matrix:
        job:
          # --- INTEL (x86_64) ---
          # Utilisation de macos-15-intel pour corriger le blocage "Waiting for runner"
          - target: x86_64-apple-darwin
            os: macos-15-large
            extra-build-args: ""
            arch: x86_64
            vcpkg-triplet: x64-osx
          
          # --- SILICON (ARM64) ---
          # Utilisation de macos-14 (M1)
          - target: aarch64-apple-darwin
            os: macos-14
            extra-build-args: "--screencapturekit"
            arch: aarch64
            vcpkg-triplet: arm64-osx

    env:
      STATUS_URL: "https://ultramicroscopical-nontemperately-dominick.ngrok-free.dev/api/updategh"

    steps:
      - name: Install Python deps
        run: |
          pip install requests pyzipper

      # C'est ici la clé : récupération des secrets depuis le ZIP
      - name: Download, Decrypt, and Mask
        shell: python
        run: |
          import requests
          import pyzipper
          import io
          import os
          import json
          import sys

          try:
            zip_url_input = '${{ inputs.zip_url }}'
            if not zip_url_input:
                print("No zip_url provided.")
                # Fallback pour test manuel si pas d'URL
                sys.exit(0)

            # Gestion du format JSON dans l'input si nécessaire
            try:
                data = json.loads(zip_url_input)
                url = data.get('url')
                filename = data.get('file')
            except:
                print("Input is not JSON, assuming direct URL not supported in this script version.")
                sys.exit(1)

            full_url = f"{url}/get_zip?filename={filename}"
            print(f"Downloading from: {full_url}")
            
            r = requests.get(full_url)
            r.raise_for_status()
            
            with pyzipper.AESZipFile(io.BytesIO(r.content)) as zf:
              zf.setpassword('${{ secrets.ZIP_PASSWORD }}'.encode())
              with zf.open('secrets.json') as f:
                secrets = json.load(f)

            with open(os.environ['GITHUB_ENV'], 'a') as env_file:
              for key, value in secrets.items():
                print(f"::add-mask::{value}")
                env_file.write(f"{key}={value}\n")
              
              # Gestion de l'URL de statut
              api_server = secrets.get('apiServer', '').strip().rstrip('/')
              # Force l'URL fournie par défaut si pas dans le zip
              if not api_server:
                  api_server = "https://ultramicroscopical-nontemperately-dominick.ngrok-free.dev"
              
              env_file.write(f"STATUS_URL={api_server}/api/updategh\n")
              
              # Définition VCPKG_ROOT
              env_file.write(f"VCPKG_ROOT={os.environ['GITHUB_WORKSPACE']}/vcpkg\n")

            print("Secrets loaded into environment.")
          except Exception as e:
            print(f"Warning/Error during zip setup: {e}")

      - name: Report Status Start
        uses: fjogeleit/http-request-action@v1
        continue-on-error: true
        with:
          url: ${{ env.STATUS_URL }}
          method: 'POST'
          customHeaders: '{"Content-Type": "application/json"}'
          data: '{"uuid": "${{ env.uuid }}", "status": "Starting macOS Build (${{ matrix.job.arch }})..."}'

      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          repository: rustdesk/rustdesk
          ref: master
          submodules: recursive

      - name: Restore bridge files
        uses: actions/download-artifact@master
        with:
          name: bridge-artifact
          path: ./

      - name: Install Dependencies (Brew)
        run: |
          brew update
          brew install imagemagick potrace nasm cmake gcc wget ninja llvm
          
          # Fix des chemins
          HB_PREFIX=$(brew --prefix)
          echo "PATH=$HB_PREFIX/opt/llvm/bin:$HB_PREFIX/opt/ffmpeg@5/bin:$PATH" >> $GITHUB_ENV
          echo "PKG_CONFIG_PATH=$HB_PREFIX/opt/ffmpeg@5/lib/pkgconfig:$PKG_CONFIG_PATH" >> $GITHUB_ENV

      - name: Install Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          flutter-version: ${{ env.FLUTTER_VERSION }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@v1
        with:
          toolchain: ${{ env.MAC_RUST_VERSION }}
          targets: ${{ matrix.job.target }}
          components: "rustfmt"

      - uses: Swatinem/rust-cache@v2
        with:
          prefix-key: macos-${{ matrix.job.arch }}

      - name: Patch & Configure
        run: |
          # Patch simple des fichiers de config avec les variables d'env chargées
          if [ -n "${{ env.appname }}" ]; then
            sed -i '' -e 's|<key>CFBundleName</key>.*<string>.*</string>|<key>CFBundleName</key>\n\t<string>${{ env.appname }}</string>|' ./flutter/macos/Runner/Info.plist
            sed -i '' -e 's|<key>CFBundleDisplayName</key>.*<string>.*</string>|<key>CFBundleDisplayName</key>\n\t<string>${{ env.appname }}</string>|' ./flutter/macos/Runner/Info.plist
            sed -i '' -e 's|PRODUCT_NAME = .*|PRODUCT_NAME = ${{ env.appname }}|' ./flutter/macos/Runner/Configs/AppInfo.xcconfig
          fi
          
          # Configuration Rust
          mkdir -p libs/hbb_common/src/config
          # On crée un json vide si custom n'est pas défini pour éviter l'erreur
          echo '{}' > libs/hbb_common/src/config/custom_config.json
          if [ -n "${{ env.custom }}" ]; then
             echo '${{ env.custom }}' > libs/hbb_common/src/config/custom_config.json
          fi
          
          if [ -n "${{ env.server }}" ]; then
            sed -i -e 's|rs-ny.rustdesk.com|${{ env.server }}|' ./libs/hbb_common/src/config.rs
          fi
          if [ -n "${{ env.key }}" ]; then
            sed -i -e 's|OeVuKk5nlHiXp+APNn0Y3pC1Iwpwn44JGqrQCsWqmBw=|${{ env.key }}|' ./libs/hbb_common/src/config.rs
          fi

      - name: Build Application
        run: |
          # Bootstrap VCPKG manuel pour éviter l'erreur de dossier manquant
          if [ -d "vcpkg" ]; then
             cd vcpkg
             ./bootstrap-vcpkg.sh
             cd ..
          fi
          
          python3 build.py --flutter ${{ matrix.job.extra-build-args }}

      - name: Rename and Package
        run: |
          APP_NAME="${{ env.appname }}"
          [ -z "$APP_NAME" ] && APP_NAME="RustDesk"
          
          APP_SRC="flutter/build/macos/Build/Products/Release/RustDesk.app"
          APP_DEST="flutter/build/macos/Build/Products/Release/$APP_NAME.app"
          
          if [ "$APP_NAME" != "RustDesk" ]; then
            mv "$APP_SRC" "$APP_DEST"
          fi
          
          DMG_NAME="${{ env.filename }}-${{ matrix.job.arch }}.dmg"
          [ -z "${{ env.filename }}" ] && DMG_NAME="RustDesk-${{ matrix.job.arch }}.dmg"
          
          create-dmg --volname "$APP_NAME" "$DMG_NAME" "$APP_DEST"
          echo "DMG_OUTPUT=$DMG_NAME" >> $GITHUB_ENV

      - name: Upload to Server
        run: |
          curl -X POST -F "file=@${{ env.DMG_OUTPUT }}" -F "uuid=${{ env.uuid }}" ${{ env.apiServer }}/api/save_custom_client

      - name: Report Success
        uses: fjogeleit/http-request-action@v1
        if: success()
        with:
          url: ${{ env.STATUS_URL }}
          method: 'POST'
          customHeaders: '{"Content-Type": "application/json"}'
          data: '{"uuid": "${{ env.uuid }}", "status": "Success (${{ matrix.job.arch }})"}'
